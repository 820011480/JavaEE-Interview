# JavaEE面试问题总结

##### @Author LucI_PhAN

## 基础篇

### 网络/IO基础

**1. BIO、NIO、AIO的概念**

1.1 同步阻塞BIO  
Blocking IO是JDK1.4之前的唯一选择，依赖于ServerSocket实现，即一个请求对应一个线程。如果线程数不够则会等待空余线程或者拒绝连接。  
在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成。只有当真正完成了IO操作以后，用户进程才能运行。

1.2 同步非阻塞NIO  
Non-Blocking IO是在JDK1.4后提供的，定义在java.nio包下。相比传统的BIO，NIO提供了告诉的面向快的I/O，它加入了Buffer，Channel，Selector等概念。它是基于事件驱动的，采用了Reactor模式。它使用一个线程管理所有的socket通道，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。  
在此种方式下，用户进程发起一个IO操作后可返回做其他事情，但是用户进程需要时不时的询问IO操作是否就绪。这需要用户进程不停地询问，从而造成了不必要的CPU资源浪费。

1.3 AIO  
AIO是NIO2.9，于JDK1.7开始应用，称为异步不阻塞IO。AIO引入异常通道的概念，采用了Proactor模式，简化了程序编写。一个有效的请求才启动一个线程。它的特点是先由操作系统完成后才通知服务器端程序启动线程去处理。  
此种方式是指用户进程发起一个IO操作以后不需等待内核IO操作的完成，内核完成以后会通知用户进程。

参考：  
[《NIo、Bio、aio、 的原理及区别与应用场景》](https://blog.csdn.net/u013851082/article/details/53942947)  
[《高级java必掌握流的几个应用：IO、BIO、NIO、AIO》](http://baijiahao.baidu.com/s?id=1570265362937061&wfr=spider&for=pc)

**2. 什么是长连接和短连接**

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。  
IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接受端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议时可靠地面向连接的。  
HTTP协议时无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议。

2.1 TCP短连接  
短连接过程：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后依次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。  
短连接一般只会在client/server间传递依次请求操作。短连接管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果client请求平凡，将在TCP的建立和关闭操作上浪费较多时间和带宽。  

2.2 TCP长连接  
长连接过程：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，他们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。  
从HTTP/1.1起，默认使用场链接，用于保持连接特性，在响应头加入Connection:keep-alive。Keep-Alie不会永久保持连接，它有一个保持时间，可以再不同的服务器软件中设定这个时间。实现长连接需要客户端和服务端都支持长连接。  
TCP的保活功能主要为服务器应用提供。报货功能就是试图在服务器端检测这种半开放的连接。  
如果一个给定的连接在一定时间内没有任何动作，服务器就向客服发送一个探测报文段，根据客户端主机响应来探测个客户端状态：
- 客户端依然运行正常且服务器可大。此时客户端TCP响应正常，服务器将保活定时器复位。
- 客户主机已经崩溃，并且关闭或者正在重新启动。客户端将无法响应TCP，服务器无法收到客户端对探测的响应，服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，他就认为客户端已经关闭并终止连接。
- 客户端已经崩溃但重新启动。此时服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
- 客户机运行正常，但是服务器不可达。这种情况与第二种状态类似。

长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。

参考:  
[《HTTP长连接、短连接究竟是什么？》](https://www.cnblogs.com/gotodsp/p/6366163.html)  
[《网络连接中的长连接和短链接是什么意思?》](https://www.zhihu.com/question/22677800)

**3. Http1.0和2.0相比有什么区别**

3.1 多路复用  
多路复用允许单一的 HTTP/2 连接同时发起多重的请求-响应消息。  
在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」  
Http/2在应用层和传输层之间增减了一个二进制分帧层。  
在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。
HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。
在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。
HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

3.2 首部压缩  
在 HTTP/1 中，HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成。一般而言，消息主体都会经过 gzip 压缩，或者本身传输的就是压缩过后的二进制文件（例如图片、音频），但状态行和头部却没有经过任何压缩，直接以纯文本传输。

随着 Web 功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输 UserAgent、Cookie 这类不会频繁变动的内容，完全是一种浪费。

3.3 HTTP2支持服务器推送  
服务端推送是一种在客户端请求之前发送数据的机制。当代网页使用了许多资源:HTML、样式表、脚本、图片等等。在HTTP/1.x中这些资源每一个都必须明确地请求。这可能是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。

为了改善延迟，HTTP/2引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前。一个服务器经常知道一个页面需要很多附加资源，在它响应浏览器第一个请求的时候，可以开始推送这些资源。这允许服务端去完全充分地利用一个可能空闲的网络，改善页面加载时间。

参考：
[《让面试官颤抖，HTTP2.0协议之你应该要准备的面试题》](https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484611&idx=1&sn=66c875392eedff8150633ddcd5d83e7a&chksm=e9c5fd72deb274648a607b9bc39bac34adadd768577b77354f6dc85422691605e210b69eeb7b&scene=21#wechat_redirect)  
[《HTTP/2.0 相比1.0有哪些重大改进？》](https://blog.csdn.net/u011904605/article/details/53025802)
