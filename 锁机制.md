# JavaEE面试问题总结

##### @Author LucI_PhAN

## 基础篇

### 锁机制


**1. 说说线程安全问题，什么是线程安全，如何保证线程安全**

线程安全指的是当多线程同时访问同一代码，不会产生不确定的结果。在多线程环境下也不会出现数据不一致的情况出现。

如果要确保线程安全，有如下几种方法：  
1. 不跨线程共享变量  
线程共享的变量改为方法局部级变量
2. 使状态变量为不可变的  
使用final修饰（将变量变为常量）
3. 在任何访问状态变量的时候使用同步  
使用synchronized修饰方法，或使用同步代码块。
4. 每个共享的可变变量都需要由唯一一个确定的锁保护。  
使用Lock锁。

[《探索并发编程（二）------写线程安全的Java代码》](https://blog.csdn.net/cutesource/article/details/5779095)

**2. 重入锁的概念，重入锁为什么可以防止死锁**

重入锁ReentrantLock是一种递归无阻塞的同步机制。它是一个可重入的互斥锁定Lock，具有与使用synchronized方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义，但功能更强大。

ReentrantLock的锁资源以state状态描述，利用CAS则实现对锁资源的抢占，并通过一个CLH队列阻塞所有竞争线程，在后续则逐个唤醒等待中的竞争线程。Reentrantlock继承AQS完全从代码层面实现了Java的同步机制，相对于synchronized，更容易实现对各种锁的扩展。同时，AbstractQueuedSynchronizer中的Condition配合ReentrantLock使用，实现了wait/notify的功能。

可重入锁可以解决某些死锁因素。比如在递归调用中，如果方法被上锁，而这个锁不可重入，在第二次调用时就会无法获得锁，造成死锁。可重入锁时针对同一个线程的，为每一个锁关联一个获取计数器和一个所有者线程，当极速器为0的时候，这个锁就没有被任何线程持有。当线程请求一个未被持有的锁时，将被记录下锁的持有者，并将计数值自增1，如果同一线程再次获取这个锁，计数值再次自增1，而只有当计数值为0时，锁才会被释放。这样就允许一个线程可以重复进入这个锁所保护的代码块，而不会在多态或递增时造成死锁。

参考:  
[《可重入锁》](https://blog.csdn.net/johnking123/article/details/50043961)  
[《深入分析ReentrantLock》](https://blog.csdn.net/jiangjiajian2008/article/details/52226189)
