# JavaEE面试问题总结

##### @Author LucI_PhAN

## 基础篇

### 锁机制


**1. 说说线程安全问题，什么是线程安全，如何保证线程安全**

线程安全指的是当多线程同时访问同一代码，不会产生不确定的结果。在多线程环境下也不会出现数据不一致的情况出现。

如果要确保线程安全，有如下几种方法：  
1. 不跨线程共享变量  
线程共享的变量改为方法局部级变量
2. 使状态变量为不可变的  
使用final修饰（将变量变为常量）
3. 在任何访问状态变量的时候使用同步  
使用synchronized修饰方法，或使用同步代码块。
4. 每个共享的可变变量都需要由唯一一个确定的锁保护。  
使用Lock锁。

[《探索并发编程（二）------写线程安全的Java代码》](https://blog.csdn.net/cutesource/article/details/5779095)

**2. 重入锁的概念，重入锁为什么可以防止死锁**

重入锁ReentrantLock是一种递归无阻塞的同步机制。它是一个可重入的互斥锁定Lock，具有与使用synchronized方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义，但功能更强大。

ReentrantLock的锁资源以state状态描述，利用CAS则实现对锁资源的抢占，并通过一个CLH队列阻塞所有竞争线程，在后续则逐个唤醒等待中的竞争线程。Reentrantlock继承AQS完全从代码层面实现了Java的同步机制，相对于synchronized，更容易实现对各种锁的扩展。同时，AbstractQueuedSynchronizer中的Condition配合ReentrantLock使用，实现了wait/notify的功能。

可重入锁可以解决某些死锁因素。比如在递归调用中，如果方法被上锁，而这个锁不可重入，在第二次调用时就会无法获得锁，造成死锁。可重入锁时针对同一个线程的，为每一个锁关联一个获取计数器和一个所有者线程，当极速器为0的时候，这个锁就没有被任何线程持有。当线程请求一个未被持有的锁时，将被记录下锁的持有者，并将计数值自增1，如果同一线程再次获取这个锁，计数值再次自增1，而只有当计数值为0时，锁才会被释放。这样就允许一个线程可以重复进入这个锁所保护的代码块，而不会在多态或递增时造成死锁。

参考:  
[《可重入锁》](https://blog.csdn.net/johnking123/article/details/50043961)  
[《深入分析ReentrantLock》](https://blog.csdn.net/jiangjiajian2008/article/details/52226189)

**3. 产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）**

如果一个进程集合里面的每个进程都在等待这个集合中的其他一个进程（包括自身）才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁，处于死锁状态的进程称为死锁进程。  
产生死锁的原因  
1. 竞争资源。系统中供多个进程共享的资源的数目不足以满足全部进程的需要时，就会引起对诸资源的竞争而发生死锁现象。  
2. 进程推进顺序不当。进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。  

要产生死锁，有四个必要条件：
1. 互斥Mutaual exclusion。有资源在某一个时刻只能被分配给一个线程使用。
2. 持有Hold And Wait。当请求的资源已被占用从而导致线程阻塞时，资源占用者不但不需要释放该资源，还可以继续请求更多的资源。
3. 不可剥夺No preemption。线程获得到的互斥资源不可被强行剥夺，也就是只有资源占用者自己才可以释放资源。
4. 环形等待Circular Wait。若干线程以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个线程组成的环形链中，每个线程都在等待下一个线程释放它持有的资源。

在线程所需求的资源中存在有限资源，当线程无法获得所需求的资源被阻塞，但拥有者在无需释放资源的情况下还被允许请求更多的其他资源，而且只有这个持有者拥有着资源的释放权力，这些线程还形成了一个你等我释放，我等你释放的环形循环等待的情况下，就发生了死锁。这四个条件都是在前者的基础上逐次升级，最终导致了死锁的发生。

参考：   
[《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)  
[《死锁产生的原因及四个必要条件》](https://blog.csdn.net/u014419806/article/details/52856589)

**4. 如何检查死锁（通过jConsole检查死锁）**
当发觉可能产生了死锁时，我们可以通过如下几种办法来检测是否真的发生了死锁。  
1. Jconsole  
找到jdk的安装位置，在bin目录下找到Jconsole，运行exe文件后选择可能发生了死锁的进程，进入后在线程中寻找左下角的<检测死锁>按钮，然后在新出现的死锁试图中查看死锁发生的线程，可以看到这些线程它们分别持有了那些锁，而需要的锁又被谁持有。
2. Jstack  
进入jdk安装目录，在目录下启动cmd，输入jps，即可产看到被怀疑产生死锁的进程的进程号。记住进程号，执行Jstack -l 进程号命名，就可以查看到死锁信息了。

[《Java如何查看死锁？》](https://blog.csdn.net/u014039577/article/details/52351626)

**5. volatile 实现原理（禁止指令重排、刷新内存）**

在JDK1.5之前，volatile因为它往往出人意料的结果而谓备受争议，在JDK1.5，这个问题解决之后，才成为一个非常关键的关键字。

如果要完全理解volatile关键字，我们必须理解内存模型和Java的内存模型。在这里就不做过多赘述了。需要了解的可以查看本题下方的参考资料链接。

volatile可以被理解为时轻量级的synchronized，他在多处理器开发中保证了共享变量的“可见性”。可见性指当一个线程修改另一个共享变量时，另一个使用同样共享变量的线程可以读到这个被修改后的值。  
Java官方对volatile定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排它锁单独获取这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，Java线程内存模型将确保所有线程看到这个变量的值是一定的。  
volatile变量修饰符如果使用恰当的话，它不会引起线程上下文的切换和调度，所以比synchronized的使用和执行成本更低。如果变量被声明了volatile关键字，则JVM在对volatile修饰的变量进行写操作时，会向处理器发送一条带有lock前缀的指令(汇编代码：0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: **lock** addl $0x0,(%esp);)。  

处理器为了提高处理速度，都是先将系统内存的数据读到内部缓存中后再进行操作，而不是直接和内存进行通讯。但操作完成之后不知道何时回写到内存。如果执行了带有lock前缀的指令，在多核处理器下会引发两个操作：
1. 将当前处理器缓存行的数据写回到系统内存
2. **这个写回内存的操作会导致其他CPU缓存了该内存地址的数据无效。**

所以当一个volatile变量更新时，所有缓存中缓存的这个变量数据都会无效化，当处理器需要对这个数据进行修改操作时，会强制重新从系统内存中把数据读到处理器缓存中。

同时请注意，在这个导致缓存无效化之前的写入操作，是被“上锁”的。多处理器环境中的LOCK#信号确保在该信号期间，处理器可以独占使用任何共享内存（信号会锁住总线，导致其他CPU不能访问总线，而不能访问总线，则意味着不能访问系统内存。）但目前最新的处理器，如果访问的内存区域已经缓存在处理器内部，则不会声明LOCK#信号。相反，会锁定这块内存区域的缓存并写回到内存，使用换从一致机制来确保修改的原子性，即缓存锁定。**缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据**。

然而无论如何都请千万注意，volatile是一种轻量级的锁，它只能保证锁的可见性，但不保证锁的原子性。譬如自增操作就不是原子性操作，因此在使用volatile时，请确保对该变量的写操作时原子性的，不然就可能造成不可预期的结果。

参考：  
[《聊聊并发（一）深入分析Volatile的实现原理》](http://ifeve.com/volatile/)  
[《Java并发编程：volatile关键字解析》](http://www.cnblogs.com/dolphin0520/p/3920373.html)  
[《Java中Volatile底层原理与应用》](https://blog.csdn.net/u012767369/article/details/55250902)

**6. synchronized 实现原理（对象监视器）**

synchronized可以保证其所修饰的方法或代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。

Java中每个对象都可以作为锁，这是synchronized实现同步的基础。
- 普通同步方法，锁是当前实例对象
- 静态同步方法，锁是当前类的class对象
- 同步方法块，锁是括号内的对象。

利用Javap工具可以查看生成的class文件信息来分析synchronize实现。  
同步代码块使用monitorenter和monitorexit执行实现，而同步方法（这里无法查看底层实现，需要了解JVM底层）依靠方法修饰符ACC_SYNCHRONIZED实现。

在同步代码块中，monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置。JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个对象监视器monitor与之相关联，且当一个monitor被持有之后，将处于锁定状态。线程执行到monitorenter指令时，会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。而这也就保证了这个锁在被释放前只会被至多一个线程获取到。

而在同步方法中，synchronized方法则会被翻译成普通的方法调用和返回指令。在VM字节码层面并没有任何的特别指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表明该方法是同步方法或该对象所属的Class在JVM的内部对象表示Klass作为锁对象。(摘自：http://www.cnblogs.com/javaminer/p/3889023.html)

参考：  
[《【死磕Java并发】—–深入分析synchronized的实现原理》](http://cmsblogs.com/?p=2071)
