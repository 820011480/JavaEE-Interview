# JavaEE面试问题总结

##### @Author LucI_PhAN

## 基础篇

### JVM

**1. JVM运行时内存区域划分**

根据《Java虚拟机规范》的规定，运行时数据区通常包括这几个部分：程序计数器Program Counter Register；Java栈VM Stack；本地方法栈Native Method Stack；方法区Method Area；堆Heap。

1.1 程序计数器  
程序计数器也被称为PC寄存器。虽然JVM中的PC并不像汇编中的PC一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的PC的功能在逻辑上是等同的，也就是说是用来指示执行哪条指令的。  
在JVM规范中规定，如果线程执行的是非native方法，则PC中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则PC中的值是undefined。  
由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象OutOfMenmory的。

1.2 Java栈  
Java栈也被称为虚拟机栈Java Vitual Machine Stack。Java栈是Java方法执行的内存模型。  
Java栈中存放的是一个个的栈帧，每一个栈帧对应一个被调用的方法，在栈帧中包括局部变量表Local Variables，操作数栈Operand Stack，指向当前方法锁属的类的运行时常量池的引用Reference to runtime constant pool，方法返回地址Return Address和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。栈这部分空间对程序员来说是不透明的。  
我们平常所说的栈一般都是指Java栈中的局部变量表。局部变量表用来存储方法中的局部变量（宝库在方法中声明的非静态变量一级函数形参）。对于基本数据类型的变量，则直接存储他的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译期就可以确定其打消了，因此在程序执行期间局部变量表的大小是不会改变的。  
由于每一个线程正在执行的方法可能不会，因此每个线程都会有一个自己的Java栈，互不干扰。

1.3 本地方法栈  
本地方法栈与Java栈的作用于原理非常相似。区别在于Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法Native Method服务的。在JVM规范中，并没有对本地方法栈的具体实现方法以及数据结构做强制规定，虚拟机可以自由实现它。在HotSpot虚拟机中就直接把本地方法栈和Java栈合二为一。  

1.4 堆  
Java中的堆是用来存储对象本身的以及数组（当然数组引用是放在Java栈中的）。堆是被所有线程共享的，在JVM中只有一个堆。  
这部分空间是Java垃圾收集器管理的主要区域。

1.5 方法区  
方法区域堆一样，是被线程共享的区域。  
在方法区中，存储了每个类的信息（包括累的名称，方法信息，字段信息），静态变量，常量以及编译器编译后的代码等。  
在方法区中有一个非常重要的部分就是运行时常量池。它是每个类或接口的常量池的运行时表示形式。在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非CLass文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。  
在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为永久代，因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，不需要专门为这部分设计垃圾回收机制。

参考：
[《JVM的内存区域划分》](http://www.importnew.com/18961.html)  
[《深入理解JVM之JVM内存区域与内存分配》](https://blog.csdn.net/USTC_Zn/article/details/54912367)

**2. 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决**

内存溢出是由于没有被引用的对象（垃圾）过多而JVM没有或无法及时回收，造成了内存溢出。  
造成内存溢出的原因可以分为两种：
- 内存泄漏：代码中的某个对象本硬背虚拟机回收，但因为拥有GCRoot引用而没有被回收。
- 内存溢出：虚拟机由于堆中拥有太多不可回收对象没有回收，导致的内存不足。

对于内存溢出，可以进行代码的检查：
1. 是否应用中的类和引用变量过多使用了static修饰。
2. 是否应用中使用了大量的递归或无线递归（递归中用到了大量的新建的对象）
3. 是否应用中使用了大量循环或死循环（循环中用到了大量的新建对象）
4. 检查应用中是否使用了像数据库查询所有记录的方法。如果数据量超过十万多条，就可能会造成内存溢出。相对的，可以采用高分页查询。
5. 检查是否有数组，list，map中存放的是对象的引用而不是对象。因为这些引用会让对应的对象不能被GC回收而大量存储于内存中。
6. 检查是否使用了非字面量字符串进行+的操作。因为String类的内容是不可变的，每次运行+就会产生新的对象。如果过多会造成内存溢出的情况。

而对于栈溢出的原因则可能有一下可能：
1. 是否有递归调用
2. 是否有大量循环或死循环
3. 全局变量是否过多
4. 数组，list，map数据是否过大
5. 使用DDMS工具进行查找大概出现栈溢出的位置。

参考：  
[《java 内存溢出 栈溢出的原因与排查方法》](https://my.oschina.net/u/2401092/blog/1621850)  
[《Java内存溢出(OOM)异常完全指南》](https://www.jianshu.com/p/2fdee831ed03)

**3. 如何判断对象是否可以回收或存活**

JVM要做垃圾回收时，首先要判断一个对象是否还有可能被使用。那么如何判断一个对象是否还有可能被用到？  
如果我们的程序无法再引用到该对象，那么这个对象就肯定可以被回收，这个状态称为不可达。当对象不可达，该对象就可以作为回收对象被垃圾回器回收。

name这个可达还是不可达如何判断呢？

答案就是GC roots，也就是跟对象。如果从一个独享没有到达根对象的路径，或者说从根对象开始无法引用到该对象，该对象就是不可达的。

以下三类对象在JVM中作为GC roots，来判断一个对象是否可以被回收（通常来说我们只需要直到虚拟机栈和静态引用就够了）
- 虚拟机栈JVM stack中引用的对象（准确的说是虚拟机栈中的栈帧frames）  
我们知道，每个方法执行的时候，JVM都会创建一个相应的栈帧（战争中包括操作数栈，局部变量表，运行时常量池的引用），栈帧中包含着在方法内部使用的所有对象的引用（当然还有其他的基本类型数据），当方法执行完后，该栈帧会从虚拟机栈中探出，这样一来，临时创建的对象的引用也就不存在了，或者说没有任何GC roots指向这些临时对象，这些对象在下一次GC是便会被回收掉
- 方法区中类静态属性引用的对象  
静态属性是该类型class的属性，不单独属于任何实例，因此该属性自然会作为GC roots。只要这个class存在，该引用指向的对象也会一直存在。
- 本地方法栈Native Stack引用的对象

而如果要回收一个class（准确说是卸载），必须同时满足以下三个条件
- 堆中不存在该类的任何实例
- 加载该类的classloader已经被回收
- 该类的java.lang.Class对象没有在任何地方被引用。也就是说无法通过反射再访问该类的信息。

参考：  
[《深入理解java虚拟机》](https://item.jd.com/11252778.html)

**4. 常见的GC回收算法及其含义**

4.1 引用计数法  
引用计数法是一种古老的垃圾手机方法。引用计数器实现很简单：对于一个对象A，有任何一个对象引用了A，nameA的计数器+1；引用是小事，A的计数器-1.当A的引用计数器是0时，A对象就不能被使用了。  
引用计数法很简单，就是额外的为每一个对象设置一个计数器用来计算引用的数量。但是缺点也是很致命的：
1. 高并发时引用计数器的每次加减操作都需要加锁，会影响系统性能。
2. 无法处理循环引用问题。比如A引用了B，B引用了A，但除此之外再没有任何引用引用到A与B。那么此时实际上A与B都不可能再被外界访问到了，但却因为计数器不为0而无法被回收。因此，在Java的垃圾回收器中，并没有使用这种算法。

4.2 标记清除法  
标记清楚算法将垃圾的回收分两阶段进行：标记阶段和清除阶段。  

在标记阶段，从根节点开始标记可到达的对象，没有被标记的对象也就是GC roots不可达对象，被认为是没有被引用的对象。而在第二阶段也就是清除阶段，将清除所有没有被标记的对象。  
这种算法最大的问题就是清除操作会产生大量的空间碎片，回收后的空间是不连续的。

4.3 复制算法  
复制算法将分配的内存空间分为2块，每次只使用一块。在垃圾回收时，将正在使用的内存中的存货对象复制到没有被使用的内存中的一块。完成之后，清除正在使用的内存块中的所有独享，然后两个内存块交换，以此完成垃圾回收。

4.4 标记压缩算法  
标记压缩算法是在标记清除算法的基础之上优化，从根节点开始，对对象的可达性做一次扫描标记，之后不是直接清除未标记的对象，而是将所有的存货对象压缩到内存的一端，之后，清除边界外的所有空间。

4.5 分区算法  
分区算法是将整个堆空间分成连续的不同的小区间，每一个小区间都是独立使用，独立回收。这样设计可以控制一次回收多少个区间，不会去全扫描。

参考：  
[《GC垃圾回收算法》](https://blog.csdn.net/qq_30739519/article/details/51111328)  
[《垃圾回收（GC）的三种基本方式》](http://blog.jobbole.com/91960/)
