# JavaEE面试问题总结

##### @Author LucI_PhAN

## 数据存储和消息队列

### 数据库

**1. MySQL 索引使用的注意事项**

1. 索引不会包含有Null值的列  
只要列中包含有null值豆浆不会被包含在索引中。符合索引中只要有一列含有null值，那么这一列对于此符合索引就是无效的。
2. 使用短索引  
对串列进行索引，如果可能应该指定一个前缀长度。例如有一个char(255)的列，如果在前10或20个字符内，多数值是惟一的，就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
3. 索引列排序  
MySQL查询只使用一个索引。因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。
4. like语句操作  
一般情况下不鼓励使用like操作。如果非使用不可，尽量避免%aaa%，因为不会使用索引，而like"aaa%"则会使用索引。
5. 不要在列上进行运算  
``` Java
select * from users where YEAR(adddate)<2007
```
将在每个行上进行运算，这将导致索引失效而进行全表扫描。可以改为
``` java
select * from users where adddate<'2007-01-01'
```
6. 不使用Not IN，<>，！=操作，但<,<=,=,>,>=,between,in是可以使用索引的
7. 索引要建立在经常进行select操作的字段上
8. 索引要建立在值比较唯一的字段上。
9. 对于那些定义为text，image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。
10. 在where和join中出现的类需要建立索引
11. where的查询条件里有不等号(where column ！= ...)，mysql将无法使用索引
12. 在join操作时，MySQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用。

参考：  
[《mysql索引使用技巧及注意事项》](https://www.cnblogs.com/heyonggang/p/6610526.html)  
[《MySQL索引类型总结和使用技巧以及注意事项》](https://blog.csdn.net/u010411264/article/details/50231903)

**2. DDL、DML、DCL分别指什么**

- 数据库操纵语言DML data mamipulation language：   
select, update, insert, delete。  
用于对数据库的数据进行一些操作
- 数据库定义语言DDL Data Define Language：  
create， alter， drop等。  
DDL主要用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上。
- 数据库控制语言DCL Data Control Language：  
grant， deny， revoke等。  
用来设置或更改数据库用户或角色权限的语句。

参考：  
[《浅谈 DML、DDL、DCL的区别》](http://www.cnblogs.com/dato/p/7049343.html)

**3. explain命令**

MySQL的explain命令用于SQL语句的查询执行计划QEP。这条命令的数据结果能够让我们了解到MySQL优化器是如何执行SQL语句的。  
这条命令并没有提供任何调整建议，但它能够提供重要的信息来帮助做出调优决策。

MySQL的explain语法可以运行在select语句或者特定表上。如果作用在表上，那么此命令等同于dedsc表命令。使用在select语句上时，只需要在SQL语句开始前加上explain。

参考：  
[《MySQL EXPLAIN 命令详解学习
》](https://blog.csdn.net/mchdba/article/details/9190771)

**4. left join，right join，inner join**

4.1 内连接inner join  
内连接使用比较运算符根据每个表公有的列的值匹配两个表中的行。

4.2 左外链接left join  
左外链接的结果集包括子句中指定的左表的所有行，而不仅仅是连接列所匹配的行。如果左表的某行在右表中没有匹配行，则结果集中国此行右表的所有选择列表均为空值。

4.3 右外链接right join  
右外连接是左外连接的反向链接，将返回右表的所有行，没有匹配数据时处理方式与左外连接相同。

**5. 数据库事物ACID（原子性、一致性、隔离性、持久性）**

- 原子性：  
  事务不可分割，组成事务的各个逻辑单元不可分割  
- 一致性：  
  事务执行的前后，数据完整性保持一致  
- 隔离性：  
  事务执行不应该受到其他事务的干扰  
- 持久性：  
  事务一旦结束，数据就持久化到数据库中  


**6. 事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）**

6.1 Read Uncommitted读未提交  
一个事务可以读取另一个未提交事务的数据。此隔离级别不能解决脏读，不可重复读和幻读问题。

6.2 Read Committed读提交  
一个事务要等另一个事务提交后才能读取数据。若有事务对数据进行update操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，，可以解决脏读，但无法解决不可重复读和幻读。  
大多数据库默认为此隔离级别，如SQL Server和Oracle。

6.3 Repeatable Read重复读  
开始读取数据（事务开启）时，不允许修改update操作。重复读可以解决脏读和不可重复读问题，但无法解决幻读问题。  
MySQL数据库默认为此隔离级别。  

6.4 Serializable序列化  
序列化是最高的事务隔离级别。在该级别下，事务串行化顺序执行，此级别以锁表的方式使得其他的线程只能在锁外等待，所以效率最为低下，非常消耗数据库性能。序列化可以解决脏读，不可重复读和幻读问题。

参考：  
[《理解事务的4种隔离级别》](https://blog.csdn.net/qq_33290787/article/details/51924963)  

**7. 脏读、幻读、不可重复读**

7.1 脏读  
脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。  
当一个事务正在多次修改一个数据，而在这个事务中这多次的修改都还未提交，这时如果一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。

7.2 不可重复读  
不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却反悔了不同的数据值。这时由于查询间隔，被另一个事务修改并提交了。  
不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

7.3 幻读（虚读）  
幻读是事务非独立执行时发生的一种现象。读取的是另一个事务insert的数据。幻读的重点在于新增或者删除（数据条数发生变化）  
例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.  
幻读和不可重复读都是读取了另一条已经提交的事务（脏读是读取未提交的事务），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体。

参考：  
[《数据库事务的四大特性以及事务的隔离级别》](http://www.cnblogs.com/fjdingsd/p/5273008.html)  
[《对于脏读，不可重复读，幻读的一点理解，看懂红字很关键》](https://blog.csdn.net/yuxin6866/article/details/52649048)

**8. 数据库的几大范式**

8.1 第一范式1NF  
数据库表的每一列都是不可分割的基本数据项。例如电话号码这个属性可以被继续分割为办公电话，手机号码等属性，在第一范式的语义下不应该作为单独的一列出现。  
在任何一个关系数据库中，第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系数据库。

8.2 第二范式2NF  
在满足第一范式的情况下，数据库表中的每一行必须是可以被唯一地区分，即每一行中有一个唯一表示将这行与其他行区分出来。这个唯一标示就是主键。  
2NF的语义下，所有非主键的字段都要依赖主键。第二范式就是一个有唯一主键在表中保证每一行都是唯一的，存在一个列被定义为唯一主键的表就是第二范式。

8.3 第三范式3NF  
在满足第一第二范式的前提下，非主键字段斗鱼主键字段有直接依赖关系，不存在传递依赖。即非主键字段只依赖主键字段，而不依赖其他的非主键字段。  
第三范式就是父子两张表，在子表中的外键是父表的主键，子表中的外键值必须是父表中的主键值。

8.4 鲍依斯-科得范式BCNF  
在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合第三范式。

8.5 第四范式4NF  
第四范式用于处理复杂的复合主键所导致的问题。第四范式用来识别那些需要花费为多个不同的实体。  
第四范式就是在一个没有段独立列被定义为唯一主键的表中用多个列组合一起被定义为唯一主键。用复合列做主键的表就是第四范式。

参考：  
[《数据库的四个范式之间的区别》](https://blog.csdn.net/hsd2012/article/details/51018631)  
[《对关系型数据库五个范式的理解》](https://blog.csdn.net/huzhaomu945/article/details/52821755)  
[《[学习笔记]数据库设计三大范式与BCNF，学习笔记》](https://www.cnblogs.com/ybwang/archive/2010/06/04/1751279.html)

**9. 数据库常见的命令**  

由于篇幅所限，这里只给出相关链接。  

参考：  
[《mysql数据库常用命令》](https://www.cnblogs.com/moss_tan_jun/p/5731901.html)  
[《数据库常用命令概括》](https://www.2cto.com/database/201610/553534.html)
